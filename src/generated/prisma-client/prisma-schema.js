module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.33.0). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateGame {
  count: Int!
}

type AggregateLedger {
  count: Int!
}

type AggregateOdd {
  count: Int!
}

type AggregateOddsType {
  count: Int!
}

type AggregateOutcome {
  count: Int!
}

type AggregateOverUnder {
  count: Int!
}

type AggregateSport {
  count: Int!
}

type AggregateTeam {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type AggregateWager {
  count: Int!
}

type AggregateWagerType {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Game {
  id: ID!
  homeTeam: Team!
  awayTeam: Team!
  gameTime: Int!
  sport: Sport!
  odds(where: OddWhereInput, orderBy: OddOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Odd!]
}

type GameConnection {
  pageInfo: PageInfo!
  edges: [GameEdge]!
  aggregate: AggregateGame!
}

input GameCreateInput {
  id: ID
  homeTeam: TeamCreateOneWithoutHomeGamesInput!
  awayTeam: TeamCreateOneWithoutAwayGamesInput!
  gameTime: Int!
  sport: SportCreateOneWithoutGameInput!
  odds: OddCreateManyWithoutGameInput
}

input GameCreateManyWithoutAwayTeamInput {
  create: [GameCreateWithoutAwayTeamInput!]
  connect: [GameWhereUniqueInput!]
}

input GameCreateManyWithoutHomeTeamInput {
  create: [GameCreateWithoutHomeTeamInput!]
  connect: [GameWhereUniqueInput!]
}

input GameCreateManyWithoutSportInput {
  create: [GameCreateWithoutSportInput!]
  connect: [GameWhereUniqueInput!]
}

input GameCreateOneWithoutOddsInput {
  create: GameCreateWithoutOddsInput
  connect: GameWhereUniqueInput
}

input GameCreateWithoutAwayTeamInput {
  id: ID
  homeTeam: TeamCreateOneWithoutHomeGamesInput!
  gameTime: Int!
  sport: SportCreateOneWithoutGameInput!
  odds: OddCreateManyWithoutGameInput
}

input GameCreateWithoutHomeTeamInput {
  id: ID
  awayTeam: TeamCreateOneWithoutAwayGamesInput!
  gameTime: Int!
  sport: SportCreateOneWithoutGameInput!
  odds: OddCreateManyWithoutGameInput
}

input GameCreateWithoutOddsInput {
  id: ID
  homeTeam: TeamCreateOneWithoutHomeGamesInput!
  awayTeam: TeamCreateOneWithoutAwayGamesInput!
  gameTime: Int!
  sport: SportCreateOneWithoutGameInput!
}

input GameCreateWithoutSportInput {
  id: ID
  homeTeam: TeamCreateOneWithoutHomeGamesInput!
  awayTeam: TeamCreateOneWithoutAwayGamesInput!
  gameTime: Int!
  odds: OddCreateManyWithoutGameInput
}

type GameEdge {
  node: Game!
  cursor: String!
}

enum GameOrderByInput {
  id_ASC
  id_DESC
  gameTime_ASC
  gameTime_DESC
}

type GamePreviousValues {
  id: ID!
  gameTime: Int!
}

input GameScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  gameTime: Int
  gameTime_not: Int
  gameTime_in: [Int!]
  gameTime_not_in: [Int!]
  gameTime_lt: Int
  gameTime_lte: Int
  gameTime_gt: Int
  gameTime_gte: Int
  AND: [GameScalarWhereInput!]
  OR: [GameScalarWhereInput!]
  NOT: [GameScalarWhereInput!]
}

type GameSubscriptionPayload {
  mutation: MutationType!
  node: Game
  updatedFields: [String!]
  previousValues: GamePreviousValues
}

input GameSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GameWhereInput
  AND: [GameSubscriptionWhereInput!]
  OR: [GameSubscriptionWhereInput!]
  NOT: [GameSubscriptionWhereInput!]
}

input GameUpdateInput {
  homeTeam: TeamUpdateOneRequiredWithoutHomeGamesInput
  awayTeam: TeamUpdateOneRequiredWithoutAwayGamesInput
  gameTime: Int
  sport: SportUpdateOneRequiredWithoutGameInput
  odds: OddUpdateManyWithoutGameInput
}

input GameUpdateManyDataInput {
  gameTime: Int
}

input GameUpdateManyMutationInput {
  gameTime: Int
}

input GameUpdateManyWithoutAwayTeamInput {
  create: [GameCreateWithoutAwayTeamInput!]
  delete: [GameWhereUniqueInput!]
  connect: [GameWhereUniqueInput!]
  set: [GameWhereUniqueInput!]
  disconnect: [GameWhereUniqueInput!]
  update: [GameUpdateWithWhereUniqueWithoutAwayTeamInput!]
  upsert: [GameUpsertWithWhereUniqueWithoutAwayTeamInput!]
  deleteMany: [GameScalarWhereInput!]
  updateMany: [GameUpdateManyWithWhereNestedInput!]
}

input GameUpdateManyWithoutHomeTeamInput {
  create: [GameCreateWithoutHomeTeamInput!]
  delete: [GameWhereUniqueInput!]
  connect: [GameWhereUniqueInput!]
  set: [GameWhereUniqueInput!]
  disconnect: [GameWhereUniqueInput!]
  update: [GameUpdateWithWhereUniqueWithoutHomeTeamInput!]
  upsert: [GameUpsertWithWhereUniqueWithoutHomeTeamInput!]
  deleteMany: [GameScalarWhereInput!]
  updateMany: [GameUpdateManyWithWhereNestedInput!]
}

input GameUpdateManyWithoutSportInput {
  create: [GameCreateWithoutSportInput!]
  delete: [GameWhereUniqueInput!]
  connect: [GameWhereUniqueInput!]
  set: [GameWhereUniqueInput!]
  disconnect: [GameWhereUniqueInput!]
  update: [GameUpdateWithWhereUniqueWithoutSportInput!]
  upsert: [GameUpsertWithWhereUniqueWithoutSportInput!]
  deleteMany: [GameScalarWhereInput!]
  updateMany: [GameUpdateManyWithWhereNestedInput!]
}

input GameUpdateManyWithWhereNestedInput {
  where: GameScalarWhereInput!
  data: GameUpdateManyDataInput!
}

input GameUpdateOneRequiredWithoutOddsInput {
  create: GameCreateWithoutOddsInput
  update: GameUpdateWithoutOddsDataInput
  upsert: GameUpsertWithoutOddsInput
  connect: GameWhereUniqueInput
}

input GameUpdateWithoutAwayTeamDataInput {
  homeTeam: TeamUpdateOneRequiredWithoutHomeGamesInput
  gameTime: Int
  sport: SportUpdateOneRequiredWithoutGameInput
  odds: OddUpdateManyWithoutGameInput
}

input GameUpdateWithoutHomeTeamDataInput {
  awayTeam: TeamUpdateOneRequiredWithoutAwayGamesInput
  gameTime: Int
  sport: SportUpdateOneRequiredWithoutGameInput
  odds: OddUpdateManyWithoutGameInput
}

input GameUpdateWithoutOddsDataInput {
  homeTeam: TeamUpdateOneRequiredWithoutHomeGamesInput
  awayTeam: TeamUpdateOneRequiredWithoutAwayGamesInput
  gameTime: Int
  sport: SportUpdateOneRequiredWithoutGameInput
}

input GameUpdateWithoutSportDataInput {
  homeTeam: TeamUpdateOneRequiredWithoutHomeGamesInput
  awayTeam: TeamUpdateOneRequiredWithoutAwayGamesInput
  gameTime: Int
  odds: OddUpdateManyWithoutGameInput
}

input GameUpdateWithWhereUniqueWithoutAwayTeamInput {
  where: GameWhereUniqueInput!
  data: GameUpdateWithoutAwayTeamDataInput!
}

input GameUpdateWithWhereUniqueWithoutHomeTeamInput {
  where: GameWhereUniqueInput!
  data: GameUpdateWithoutHomeTeamDataInput!
}

input GameUpdateWithWhereUniqueWithoutSportInput {
  where: GameWhereUniqueInput!
  data: GameUpdateWithoutSportDataInput!
}

input GameUpsertWithoutOddsInput {
  update: GameUpdateWithoutOddsDataInput!
  create: GameCreateWithoutOddsInput!
}

input GameUpsertWithWhereUniqueWithoutAwayTeamInput {
  where: GameWhereUniqueInput!
  update: GameUpdateWithoutAwayTeamDataInput!
  create: GameCreateWithoutAwayTeamInput!
}

input GameUpsertWithWhereUniqueWithoutHomeTeamInput {
  where: GameWhereUniqueInput!
  update: GameUpdateWithoutHomeTeamDataInput!
  create: GameCreateWithoutHomeTeamInput!
}

input GameUpsertWithWhereUniqueWithoutSportInput {
  where: GameWhereUniqueInput!
  update: GameUpdateWithoutSportDataInput!
  create: GameCreateWithoutSportInput!
}

input GameWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  homeTeam: TeamWhereInput
  awayTeam: TeamWhereInput
  gameTime: Int
  gameTime_not: Int
  gameTime_in: [Int!]
  gameTime_not_in: [Int!]
  gameTime_lt: Int
  gameTime_lte: Int
  gameTime_gt: Int
  gameTime_gte: Int
  sport: SportWhereInput
  odds_every: OddWhereInput
  odds_some: OddWhereInput
  odds_none: OddWhereInput
  AND: [GameWhereInput!]
  OR: [GameWhereInput!]
  NOT: [GameWhereInput!]
}

input GameWhereUniqueInput {
  id: ID
}

type Ledger {
  id: ID!
  amountWagered: Float!
  collected: Float
  payout: Float
  entryTime: Int!
  user: User!
  wagerType: WagerType!
  outcome: Outcome!
}

type LedgerConnection {
  pageInfo: PageInfo!
  edges: [LedgerEdge]!
  aggregate: AggregateLedger!
}

input LedgerCreateInput {
  id: ID
  amountWagered: Float!
  collected: Float
  payout: Float
  entryTime: Int!
  user: UserCreateOneWithoutLedgerEntriesInput!
  wagerType: WagerTypeCreateOneWithoutLedgersInput!
  outcome: OutcomeCreateOneWithoutLedgersInput!
}

input LedgerCreateManyWithoutOutcomeInput {
  create: [LedgerCreateWithoutOutcomeInput!]
  connect: [LedgerWhereUniqueInput!]
}

input LedgerCreateManyWithoutUserInput {
  create: [LedgerCreateWithoutUserInput!]
  connect: [LedgerWhereUniqueInput!]
}

input LedgerCreateManyWithoutWagerTypeInput {
  create: [LedgerCreateWithoutWagerTypeInput!]
  connect: [LedgerWhereUniqueInput!]
}

input LedgerCreateOneInput {
  create: LedgerCreateInput
  connect: LedgerWhereUniqueInput
}

input LedgerCreateWithoutOutcomeInput {
  id: ID
  amountWagered: Float!
  collected: Float
  payout: Float
  entryTime: Int!
  user: UserCreateOneWithoutLedgerEntriesInput!
  wagerType: WagerTypeCreateOneWithoutLedgersInput!
}

input LedgerCreateWithoutUserInput {
  id: ID
  amountWagered: Float!
  collected: Float
  payout: Float
  entryTime: Int!
  wagerType: WagerTypeCreateOneWithoutLedgersInput!
  outcome: OutcomeCreateOneWithoutLedgersInput!
}

input LedgerCreateWithoutWagerTypeInput {
  id: ID
  amountWagered: Float!
  collected: Float
  payout: Float
  entryTime: Int!
  user: UserCreateOneWithoutLedgerEntriesInput!
  outcome: OutcomeCreateOneWithoutLedgersInput!
}

type LedgerEdge {
  node: Ledger!
  cursor: String!
}

enum LedgerOrderByInput {
  id_ASC
  id_DESC
  amountWagered_ASC
  amountWagered_DESC
  collected_ASC
  collected_DESC
  payout_ASC
  payout_DESC
  entryTime_ASC
  entryTime_DESC
}

type LedgerPreviousValues {
  id: ID!
  amountWagered: Float!
  collected: Float
  payout: Float
  entryTime: Int!
}

input LedgerScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  amountWagered: Float
  amountWagered_not: Float
  amountWagered_in: [Float!]
  amountWagered_not_in: [Float!]
  amountWagered_lt: Float
  amountWagered_lte: Float
  amountWagered_gt: Float
  amountWagered_gte: Float
  collected: Float
  collected_not: Float
  collected_in: [Float!]
  collected_not_in: [Float!]
  collected_lt: Float
  collected_lte: Float
  collected_gt: Float
  collected_gte: Float
  payout: Float
  payout_not: Float
  payout_in: [Float!]
  payout_not_in: [Float!]
  payout_lt: Float
  payout_lte: Float
  payout_gt: Float
  payout_gte: Float
  entryTime: Int
  entryTime_not: Int
  entryTime_in: [Int!]
  entryTime_not_in: [Int!]
  entryTime_lt: Int
  entryTime_lte: Int
  entryTime_gt: Int
  entryTime_gte: Int
  AND: [LedgerScalarWhereInput!]
  OR: [LedgerScalarWhereInput!]
  NOT: [LedgerScalarWhereInput!]
}

type LedgerSubscriptionPayload {
  mutation: MutationType!
  node: Ledger
  updatedFields: [String!]
  previousValues: LedgerPreviousValues
}

input LedgerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LedgerWhereInput
  AND: [LedgerSubscriptionWhereInput!]
  OR: [LedgerSubscriptionWhereInput!]
  NOT: [LedgerSubscriptionWhereInput!]
}

input LedgerUpdateDataInput {
  amountWagered: Float
  collected: Float
  payout: Float
  entryTime: Int
  user: UserUpdateOneRequiredWithoutLedgerEntriesInput
  wagerType: WagerTypeUpdateOneRequiredWithoutLedgersInput
  outcome: OutcomeUpdateOneRequiredWithoutLedgersInput
}

input LedgerUpdateInput {
  amountWagered: Float
  collected: Float
  payout: Float
  entryTime: Int
  user: UserUpdateOneRequiredWithoutLedgerEntriesInput
  wagerType: WagerTypeUpdateOneRequiredWithoutLedgersInput
  outcome: OutcomeUpdateOneRequiredWithoutLedgersInput
}

input LedgerUpdateManyDataInput {
  amountWagered: Float
  collected: Float
  payout: Float
  entryTime: Int
}

input LedgerUpdateManyMutationInput {
  amountWagered: Float
  collected: Float
  payout: Float
  entryTime: Int
}

input LedgerUpdateManyWithoutOutcomeInput {
  create: [LedgerCreateWithoutOutcomeInput!]
  delete: [LedgerWhereUniqueInput!]
  connect: [LedgerWhereUniqueInput!]
  set: [LedgerWhereUniqueInput!]
  disconnect: [LedgerWhereUniqueInput!]
  update: [LedgerUpdateWithWhereUniqueWithoutOutcomeInput!]
  upsert: [LedgerUpsertWithWhereUniqueWithoutOutcomeInput!]
  deleteMany: [LedgerScalarWhereInput!]
  updateMany: [LedgerUpdateManyWithWhereNestedInput!]
}

input LedgerUpdateManyWithoutUserInput {
  create: [LedgerCreateWithoutUserInput!]
  delete: [LedgerWhereUniqueInput!]
  connect: [LedgerWhereUniqueInput!]
  set: [LedgerWhereUniqueInput!]
  disconnect: [LedgerWhereUniqueInput!]
  update: [LedgerUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [LedgerUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [LedgerScalarWhereInput!]
  updateMany: [LedgerUpdateManyWithWhereNestedInput!]
}

input LedgerUpdateManyWithoutWagerTypeInput {
  create: [LedgerCreateWithoutWagerTypeInput!]
  delete: [LedgerWhereUniqueInput!]
  connect: [LedgerWhereUniqueInput!]
  set: [LedgerWhereUniqueInput!]
  disconnect: [LedgerWhereUniqueInput!]
  update: [LedgerUpdateWithWhereUniqueWithoutWagerTypeInput!]
  upsert: [LedgerUpsertWithWhereUniqueWithoutWagerTypeInput!]
  deleteMany: [LedgerScalarWhereInput!]
  updateMany: [LedgerUpdateManyWithWhereNestedInput!]
}

input LedgerUpdateManyWithWhereNestedInput {
  where: LedgerScalarWhereInput!
  data: LedgerUpdateManyDataInput!
}

input LedgerUpdateOneRequiredInput {
  create: LedgerCreateInput
  update: LedgerUpdateDataInput
  upsert: LedgerUpsertNestedInput
  connect: LedgerWhereUniqueInput
}

input LedgerUpdateWithoutOutcomeDataInput {
  amountWagered: Float
  collected: Float
  payout: Float
  entryTime: Int
  user: UserUpdateOneRequiredWithoutLedgerEntriesInput
  wagerType: WagerTypeUpdateOneRequiredWithoutLedgersInput
}

input LedgerUpdateWithoutUserDataInput {
  amountWagered: Float
  collected: Float
  payout: Float
  entryTime: Int
  wagerType: WagerTypeUpdateOneRequiredWithoutLedgersInput
  outcome: OutcomeUpdateOneRequiredWithoutLedgersInput
}

input LedgerUpdateWithoutWagerTypeDataInput {
  amountWagered: Float
  collected: Float
  payout: Float
  entryTime: Int
  user: UserUpdateOneRequiredWithoutLedgerEntriesInput
  outcome: OutcomeUpdateOneRequiredWithoutLedgersInput
}

input LedgerUpdateWithWhereUniqueWithoutOutcomeInput {
  where: LedgerWhereUniqueInput!
  data: LedgerUpdateWithoutOutcomeDataInput!
}

input LedgerUpdateWithWhereUniqueWithoutUserInput {
  where: LedgerWhereUniqueInput!
  data: LedgerUpdateWithoutUserDataInput!
}

input LedgerUpdateWithWhereUniqueWithoutWagerTypeInput {
  where: LedgerWhereUniqueInput!
  data: LedgerUpdateWithoutWagerTypeDataInput!
}

input LedgerUpsertNestedInput {
  update: LedgerUpdateDataInput!
  create: LedgerCreateInput!
}

input LedgerUpsertWithWhereUniqueWithoutOutcomeInput {
  where: LedgerWhereUniqueInput!
  update: LedgerUpdateWithoutOutcomeDataInput!
  create: LedgerCreateWithoutOutcomeInput!
}

input LedgerUpsertWithWhereUniqueWithoutUserInput {
  where: LedgerWhereUniqueInput!
  update: LedgerUpdateWithoutUserDataInput!
  create: LedgerCreateWithoutUserInput!
}

input LedgerUpsertWithWhereUniqueWithoutWagerTypeInput {
  where: LedgerWhereUniqueInput!
  update: LedgerUpdateWithoutWagerTypeDataInput!
  create: LedgerCreateWithoutWagerTypeInput!
}

input LedgerWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  amountWagered: Float
  amountWagered_not: Float
  amountWagered_in: [Float!]
  amountWagered_not_in: [Float!]
  amountWagered_lt: Float
  amountWagered_lte: Float
  amountWagered_gt: Float
  amountWagered_gte: Float
  collected: Float
  collected_not: Float
  collected_in: [Float!]
  collected_not_in: [Float!]
  collected_lt: Float
  collected_lte: Float
  collected_gt: Float
  collected_gte: Float
  payout: Float
  payout_not: Float
  payout_in: [Float!]
  payout_not_in: [Float!]
  payout_lt: Float
  payout_lte: Float
  payout_gt: Float
  payout_gte: Float
  entryTime: Int
  entryTime_not: Int
  entryTime_in: [Int!]
  entryTime_not_in: [Int!]
  entryTime_lt: Int
  entryTime_lte: Int
  entryTime_gt: Int
  entryTime_gte: Int
  user: UserWhereInput
  wagerType: WagerTypeWhereInput
  outcome: OutcomeWhereInput
  AND: [LedgerWhereInput!]
  OR: [LedgerWhereInput!]
  NOT: [LedgerWhereInput!]
}

input LedgerWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createGame(data: GameCreateInput!): Game!
  updateGame(data: GameUpdateInput!, where: GameWhereUniqueInput!): Game
  updateManyGames(data: GameUpdateManyMutationInput!, where: GameWhereInput): BatchPayload!
  upsertGame(where: GameWhereUniqueInput!, create: GameCreateInput!, update: GameUpdateInput!): Game!
  deleteGame(where: GameWhereUniqueInput!): Game
  deleteManyGames(where: GameWhereInput): BatchPayload!
  createLedger(data: LedgerCreateInput!): Ledger!
  updateLedger(data: LedgerUpdateInput!, where: LedgerWhereUniqueInput!): Ledger
  updateManyLedgers(data: LedgerUpdateManyMutationInput!, where: LedgerWhereInput): BatchPayload!
  upsertLedger(where: LedgerWhereUniqueInput!, create: LedgerCreateInput!, update: LedgerUpdateInput!): Ledger!
  deleteLedger(where: LedgerWhereUniqueInput!): Ledger
  deleteManyLedgers(where: LedgerWhereInput): BatchPayload!
  createOdd(data: OddCreateInput!): Odd!
  updateOdd(data: OddUpdateInput!, where: OddWhereUniqueInput!): Odd
  updateManyOdds(data: OddUpdateManyMutationInput!, where: OddWhereInput): BatchPayload!
  upsertOdd(where: OddWhereUniqueInput!, create: OddCreateInput!, update: OddUpdateInput!): Odd!
  deleteOdd(where: OddWhereUniqueInput!): Odd
  deleteManyOdds(where: OddWhereInput): BatchPayload!
  createOddsType(data: OddsTypeCreateInput!): OddsType!
  updateOddsType(data: OddsTypeUpdateInput!, where: OddsTypeWhereUniqueInput!): OddsType
  updateManyOddsTypes(data: OddsTypeUpdateManyMutationInput!, where: OddsTypeWhereInput): BatchPayload!
  upsertOddsType(where: OddsTypeWhereUniqueInput!, create: OddsTypeCreateInput!, update: OddsTypeUpdateInput!): OddsType!
  deleteOddsType(where: OddsTypeWhereUniqueInput!): OddsType
  deleteManyOddsTypes(where: OddsTypeWhereInput): BatchPayload!
  createOutcome(data: OutcomeCreateInput!): Outcome!
  updateOutcome(data: OutcomeUpdateInput!, where: OutcomeWhereUniqueInput!): Outcome
  updateManyOutcomes(data: OutcomeUpdateManyMutationInput!, where: OutcomeWhereInput): BatchPayload!
  upsertOutcome(where: OutcomeWhereUniqueInput!, create: OutcomeCreateInput!, update: OutcomeUpdateInput!): Outcome!
  deleteOutcome(where: OutcomeWhereUniqueInput!): Outcome
  deleteManyOutcomes(where: OutcomeWhereInput): BatchPayload!
  createOverUnder(data: OverUnderCreateInput!): OverUnder!
  updateOverUnder(data: OverUnderUpdateInput!, where: OverUnderWhereUniqueInput!): OverUnder
  updateManyOverUnders(data: OverUnderUpdateManyMutationInput!, where: OverUnderWhereInput): BatchPayload!
  upsertOverUnder(where: OverUnderWhereUniqueInput!, create: OverUnderCreateInput!, update: OverUnderUpdateInput!): OverUnder!
  deleteOverUnder(where: OverUnderWhereUniqueInput!): OverUnder
  deleteManyOverUnders(where: OverUnderWhereInput): BatchPayload!
  createSport(data: SportCreateInput!): Sport!
  updateSport(data: SportUpdateInput!, where: SportWhereUniqueInput!): Sport
  updateManySports(data: SportUpdateManyMutationInput!, where: SportWhereInput): BatchPayload!
  upsertSport(where: SportWhereUniqueInput!, create: SportCreateInput!, update: SportUpdateInput!): Sport!
  deleteSport(where: SportWhereUniqueInput!): Sport
  deleteManySports(where: SportWhereInput): BatchPayload!
  createTeam(data: TeamCreateInput!): Team!
  updateTeam(data: TeamUpdateInput!, where: TeamWhereUniqueInput!): Team
  updateManyTeams(data: TeamUpdateManyMutationInput!, where: TeamWhereInput): BatchPayload!
  upsertTeam(where: TeamWhereUniqueInput!, create: TeamCreateInput!, update: TeamUpdateInput!): Team!
  deleteTeam(where: TeamWhereUniqueInput!): Team
  deleteManyTeams(where: TeamWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
  createWager(data: WagerCreateInput!): Wager!
  updateWager(data: WagerUpdateInput!, where: WagerWhereUniqueInput!): Wager
  upsertWager(where: WagerWhereUniqueInput!, create: WagerCreateInput!, update: WagerUpdateInput!): Wager!
  deleteWager(where: WagerWhereUniqueInput!): Wager
  deleteManyWagers(where: WagerWhereInput): BatchPayload!
  createWagerType(data: WagerTypeCreateInput!): WagerType!
  updateWagerType(data: WagerTypeUpdateInput!, where: WagerTypeWhereUniqueInput!): WagerType
  updateManyWagerTypes(data: WagerTypeUpdateManyMutationInput!, where: WagerTypeWhereInput): BatchPayload!
  upsertWagerType(where: WagerTypeWhereUniqueInput!, create: WagerTypeCreateInput!, update: WagerTypeUpdateInput!): WagerType!
  deleteWagerType(where: WagerTypeWhereUniqueInput!): WagerType
  deleteManyWagerTypes(where: WagerTypeWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type Odd {
  id: ID!
  game: Game!
  moneyLine: Int
  runLineOdds: Int
  runLineRuns: Float
  overUnderOdds: Int
  overUnderRuns: Float
  timeOfOdds: Int!
}

type OddConnection {
  pageInfo: PageInfo!
  edges: [OddEdge]!
  aggregate: AggregateOdd!
}

input OddCreateInput {
  id: ID
  game: GameCreateOneWithoutOddsInput!
  moneyLine: Int
  runLineOdds: Int
  runLineRuns: Float
  overUnderOdds: Int
  overUnderRuns: Float
  timeOfOdds: Int!
}

input OddCreateManyWithoutGameInput {
  create: [OddCreateWithoutGameInput!]
  connect: [OddWhereUniqueInput!]
}

input OddCreateOneInput {
  create: OddCreateInput
  connect: OddWhereUniqueInput
}

input OddCreateWithoutGameInput {
  id: ID
  moneyLine: Int
  runLineOdds: Int
  runLineRuns: Float
  overUnderOdds: Int
  overUnderRuns: Float
  timeOfOdds: Int!
}

type OddEdge {
  node: Odd!
  cursor: String!
}

enum OddOrderByInput {
  id_ASC
  id_DESC
  moneyLine_ASC
  moneyLine_DESC
  runLineOdds_ASC
  runLineOdds_DESC
  runLineRuns_ASC
  runLineRuns_DESC
  overUnderOdds_ASC
  overUnderOdds_DESC
  overUnderRuns_ASC
  overUnderRuns_DESC
  timeOfOdds_ASC
  timeOfOdds_DESC
}

type OddPreviousValues {
  id: ID!
  moneyLine: Int
  runLineOdds: Int
  runLineRuns: Float
  overUnderOdds: Int
  overUnderRuns: Float
  timeOfOdds: Int!
}

input OddScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  moneyLine: Int
  moneyLine_not: Int
  moneyLine_in: [Int!]
  moneyLine_not_in: [Int!]
  moneyLine_lt: Int
  moneyLine_lte: Int
  moneyLine_gt: Int
  moneyLine_gte: Int
  runLineOdds: Int
  runLineOdds_not: Int
  runLineOdds_in: [Int!]
  runLineOdds_not_in: [Int!]
  runLineOdds_lt: Int
  runLineOdds_lte: Int
  runLineOdds_gt: Int
  runLineOdds_gte: Int
  runLineRuns: Float
  runLineRuns_not: Float
  runLineRuns_in: [Float!]
  runLineRuns_not_in: [Float!]
  runLineRuns_lt: Float
  runLineRuns_lte: Float
  runLineRuns_gt: Float
  runLineRuns_gte: Float
  overUnderOdds: Int
  overUnderOdds_not: Int
  overUnderOdds_in: [Int!]
  overUnderOdds_not_in: [Int!]
  overUnderOdds_lt: Int
  overUnderOdds_lte: Int
  overUnderOdds_gt: Int
  overUnderOdds_gte: Int
  overUnderRuns: Float
  overUnderRuns_not: Float
  overUnderRuns_in: [Float!]
  overUnderRuns_not_in: [Float!]
  overUnderRuns_lt: Float
  overUnderRuns_lte: Float
  overUnderRuns_gt: Float
  overUnderRuns_gte: Float
  timeOfOdds: Int
  timeOfOdds_not: Int
  timeOfOdds_in: [Int!]
  timeOfOdds_not_in: [Int!]
  timeOfOdds_lt: Int
  timeOfOdds_lte: Int
  timeOfOdds_gt: Int
  timeOfOdds_gte: Int
  AND: [OddScalarWhereInput!]
  OR: [OddScalarWhereInput!]
  NOT: [OddScalarWhereInput!]
}

type OddsType {
  id: ID!
  oddsType: String!
}

type OddsTypeConnection {
  pageInfo: PageInfo!
  edges: [OddsTypeEdge]!
  aggregate: AggregateOddsType!
}

input OddsTypeCreateInput {
  id: ID
  oddsType: String!
}

input OddsTypeCreateOneInput {
  create: OddsTypeCreateInput
  connect: OddsTypeWhereUniqueInput
}

type OddsTypeEdge {
  node: OddsType!
  cursor: String!
}

enum OddsTypeOrderByInput {
  id_ASC
  id_DESC
  oddsType_ASC
  oddsType_DESC
}

type OddsTypePreviousValues {
  id: ID!
  oddsType: String!
}

type OddsTypeSubscriptionPayload {
  mutation: MutationType!
  node: OddsType
  updatedFields: [String!]
  previousValues: OddsTypePreviousValues
}

input OddsTypeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: OddsTypeWhereInput
  AND: [OddsTypeSubscriptionWhereInput!]
  OR: [OddsTypeSubscriptionWhereInput!]
  NOT: [OddsTypeSubscriptionWhereInput!]
}

input OddsTypeUpdateDataInput {
  oddsType: String
}

input OddsTypeUpdateInput {
  oddsType: String
}

input OddsTypeUpdateManyMutationInput {
  oddsType: String
}

input OddsTypeUpdateOneRequiredInput {
  create: OddsTypeCreateInput
  update: OddsTypeUpdateDataInput
  upsert: OddsTypeUpsertNestedInput
  connect: OddsTypeWhereUniqueInput
}

input OddsTypeUpsertNestedInput {
  update: OddsTypeUpdateDataInput!
  create: OddsTypeCreateInput!
}

input OddsTypeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  oddsType: String
  oddsType_not: String
  oddsType_in: [String!]
  oddsType_not_in: [String!]
  oddsType_lt: String
  oddsType_lte: String
  oddsType_gt: String
  oddsType_gte: String
  oddsType_contains: String
  oddsType_not_contains: String
  oddsType_starts_with: String
  oddsType_not_starts_with: String
  oddsType_ends_with: String
  oddsType_not_ends_with: String
  AND: [OddsTypeWhereInput!]
  OR: [OddsTypeWhereInput!]
  NOT: [OddsTypeWhereInput!]
}

input OddsTypeWhereUniqueInput {
  id: ID
}

type OddSubscriptionPayload {
  mutation: MutationType!
  node: Odd
  updatedFields: [String!]
  previousValues: OddPreviousValues
}

input OddSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: OddWhereInput
  AND: [OddSubscriptionWhereInput!]
  OR: [OddSubscriptionWhereInput!]
  NOT: [OddSubscriptionWhereInput!]
}

input OddUpdateDataInput {
  game: GameUpdateOneRequiredWithoutOddsInput
  moneyLine: Int
  runLineOdds: Int
  runLineRuns: Float
  overUnderOdds: Int
  overUnderRuns: Float
  timeOfOdds: Int
}

input OddUpdateInput {
  game: GameUpdateOneRequiredWithoutOddsInput
  moneyLine: Int
  runLineOdds: Int
  runLineRuns: Float
  overUnderOdds: Int
  overUnderRuns: Float
  timeOfOdds: Int
}

input OddUpdateManyDataInput {
  moneyLine: Int
  runLineOdds: Int
  runLineRuns: Float
  overUnderOdds: Int
  overUnderRuns: Float
  timeOfOdds: Int
}

input OddUpdateManyMutationInput {
  moneyLine: Int
  runLineOdds: Int
  runLineRuns: Float
  overUnderOdds: Int
  overUnderRuns: Float
  timeOfOdds: Int
}

input OddUpdateManyWithoutGameInput {
  create: [OddCreateWithoutGameInput!]
  delete: [OddWhereUniqueInput!]
  connect: [OddWhereUniqueInput!]
  set: [OddWhereUniqueInput!]
  disconnect: [OddWhereUniqueInput!]
  update: [OddUpdateWithWhereUniqueWithoutGameInput!]
  upsert: [OddUpsertWithWhereUniqueWithoutGameInput!]
  deleteMany: [OddScalarWhereInput!]
  updateMany: [OddUpdateManyWithWhereNestedInput!]
}

input OddUpdateManyWithWhereNestedInput {
  where: OddScalarWhereInput!
  data: OddUpdateManyDataInput!
}

input OddUpdateOneRequiredInput {
  create: OddCreateInput
  update: OddUpdateDataInput
  upsert: OddUpsertNestedInput
  connect: OddWhereUniqueInput
}

input OddUpdateWithoutGameDataInput {
  moneyLine: Int
  runLineOdds: Int
  runLineRuns: Float
  overUnderOdds: Int
  overUnderRuns: Float
  timeOfOdds: Int
}

input OddUpdateWithWhereUniqueWithoutGameInput {
  where: OddWhereUniqueInput!
  data: OddUpdateWithoutGameDataInput!
}

input OddUpsertNestedInput {
  update: OddUpdateDataInput!
  create: OddCreateInput!
}

input OddUpsertWithWhereUniqueWithoutGameInput {
  where: OddWhereUniqueInput!
  update: OddUpdateWithoutGameDataInput!
  create: OddCreateWithoutGameInput!
}

input OddWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  game: GameWhereInput
  moneyLine: Int
  moneyLine_not: Int
  moneyLine_in: [Int!]
  moneyLine_not_in: [Int!]
  moneyLine_lt: Int
  moneyLine_lte: Int
  moneyLine_gt: Int
  moneyLine_gte: Int
  runLineOdds: Int
  runLineOdds_not: Int
  runLineOdds_in: [Int!]
  runLineOdds_not_in: [Int!]
  runLineOdds_lt: Int
  runLineOdds_lte: Int
  runLineOdds_gt: Int
  runLineOdds_gte: Int
  runLineRuns: Float
  runLineRuns_not: Float
  runLineRuns_in: [Float!]
  runLineRuns_not_in: [Float!]
  runLineRuns_lt: Float
  runLineRuns_lte: Float
  runLineRuns_gt: Float
  runLineRuns_gte: Float
  overUnderOdds: Int
  overUnderOdds_not: Int
  overUnderOdds_in: [Int!]
  overUnderOdds_not_in: [Int!]
  overUnderOdds_lt: Int
  overUnderOdds_lte: Int
  overUnderOdds_gt: Int
  overUnderOdds_gte: Int
  overUnderRuns: Float
  overUnderRuns_not: Float
  overUnderRuns_in: [Float!]
  overUnderRuns_not_in: [Float!]
  overUnderRuns_lt: Float
  overUnderRuns_lte: Float
  overUnderRuns_gt: Float
  overUnderRuns_gte: Float
  timeOfOdds: Int
  timeOfOdds_not: Int
  timeOfOdds_in: [Int!]
  timeOfOdds_not_in: [Int!]
  timeOfOdds_lt: Int
  timeOfOdds_lte: Int
  timeOfOdds_gt: Int
  timeOfOdds_gte: Int
  AND: [OddWhereInput!]
  OR: [OddWhereInput!]
  NOT: [OddWhereInput!]
}

input OddWhereUniqueInput {
  id: ID
}

type Outcome {
  id: ID!
  outcome: String!
  ledgers(where: LedgerWhereInput, orderBy: LedgerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Ledger!]
}

type OutcomeConnection {
  pageInfo: PageInfo!
  edges: [OutcomeEdge]!
  aggregate: AggregateOutcome!
}

input OutcomeCreateInput {
  id: ID
  outcome: String!
  ledgers: LedgerCreateManyWithoutOutcomeInput
}

input OutcomeCreateOneWithoutLedgersInput {
  create: OutcomeCreateWithoutLedgersInput
  connect: OutcomeWhereUniqueInput
}

input OutcomeCreateWithoutLedgersInput {
  id: ID
  outcome: String!
}

type OutcomeEdge {
  node: Outcome!
  cursor: String!
}

enum OutcomeOrderByInput {
  id_ASC
  id_DESC
  outcome_ASC
  outcome_DESC
}

type OutcomePreviousValues {
  id: ID!
  outcome: String!
}

type OutcomeSubscriptionPayload {
  mutation: MutationType!
  node: Outcome
  updatedFields: [String!]
  previousValues: OutcomePreviousValues
}

input OutcomeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: OutcomeWhereInput
  AND: [OutcomeSubscriptionWhereInput!]
  OR: [OutcomeSubscriptionWhereInput!]
  NOT: [OutcomeSubscriptionWhereInput!]
}

input OutcomeUpdateInput {
  outcome: String
  ledgers: LedgerUpdateManyWithoutOutcomeInput
}

input OutcomeUpdateManyMutationInput {
  outcome: String
}

input OutcomeUpdateOneRequiredWithoutLedgersInput {
  create: OutcomeCreateWithoutLedgersInput
  update: OutcomeUpdateWithoutLedgersDataInput
  upsert: OutcomeUpsertWithoutLedgersInput
  connect: OutcomeWhereUniqueInput
}

input OutcomeUpdateWithoutLedgersDataInput {
  outcome: String
}

input OutcomeUpsertWithoutLedgersInput {
  update: OutcomeUpdateWithoutLedgersDataInput!
  create: OutcomeCreateWithoutLedgersInput!
}

input OutcomeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  outcome: String
  outcome_not: String
  outcome_in: [String!]
  outcome_not_in: [String!]
  outcome_lt: String
  outcome_lte: String
  outcome_gt: String
  outcome_gte: String
  outcome_contains: String
  outcome_not_contains: String
  outcome_starts_with: String
  outcome_not_starts_with: String
  outcome_ends_with: String
  outcome_not_ends_with: String
  ledgers_every: LedgerWhereInput
  ledgers_some: LedgerWhereInput
  ledgers_none: LedgerWhereInput
  AND: [OutcomeWhereInput!]
  OR: [OutcomeWhereInput!]
  NOT: [OutcomeWhereInput!]
}

input OutcomeWhereUniqueInput {
  id: ID
}

type OverUnder {
  id: ID!
  value: Boolean!
  overUnder: String!
}

type OverUnderConnection {
  pageInfo: PageInfo!
  edges: [OverUnderEdge]!
  aggregate: AggregateOverUnder!
}

input OverUnderCreateInput {
  id: ID
  value: Boolean!
  overUnder: String!
}

input OverUnderCreateOneInput {
  create: OverUnderCreateInput
  connect: OverUnderWhereUniqueInput
}

type OverUnderEdge {
  node: OverUnder!
  cursor: String!
}

enum OverUnderOrderByInput {
  id_ASC
  id_DESC
  value_ASC
  value_DESC
  overUnder_ASC
  overUnder_DESC
}

type OverUnderPreviousValues {
  id: ID!
  value: Boolean!
  overUnder: String!
}

type OverUnderSubscriptionPayload {
  mutation: MutationType!
  node: OverUnder
  updatedFields: [String!]
  previousValues: OverUnderPreviousValues
}

input OverUnderSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: OverUnderWhereInput
  AND: [OverUnderSubscriptionWhereInput!]
  OR: [OverUnderSubscriptionWhereInput!]
  NOT: [OverUnderSubscriptionWhereInput!]
}

input OverUnderUpdateDataInput {
  value: Boolean
  overUnder: String
}

input OverUnderUpdateInput {
  value: Boolean
  overUnder: String
}

input OverUnderUpdateManyMutationInput {
  value: Boolean
  overUnder: String
}

input OverUnderUpdateOneInput {
  create: OverUnderCreateInput
  update: OverUnderUpdateDataInput
  upsert: OverUnderUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: OverUnderWhereUniqueInput
}

input OverUnderUpsertNestedInput {
  update: OverUnderUpdateDataInput!
  create: OverUnderCreateInput!
}

input OverUnderWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  value: Boolean
  value_not: Boolean
  overUnder: String
  overUnder_not: String
  overUnder_in: [String!]
  overUnder_not_in: [String!]
  overUnder_lt: String
  overUnder_lte: String
  overUnder_gt: String
  overUnder_gte: String
  overUnder_contains: String
  overUnder_not_contains: String
  overUnder_starts_with: String
  overUnder_not_starts_with: String
  overUnder_ends_with: String
  overUnder_not_ends_with: String
  AND: [OverUnderWhereInput!]
  OR: [OverUnderWhereInput!]
  NOT: [OverUnderWhereInput!]
}

input OverUnderWhereUniqueInput {
  id: ID
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  game(where: GameWhereUniqueInput!): Game
  games(where: GameWhereInput, orderBy: GameOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Game]!
  gamesConnection(where: GameWhereInput, orderBy: GameOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GameConnection!
  ledger(where: LedgerWhereUniqueInput!): Ledger
  ledgers(where: LedgerWhereInput, orderBy: LedgerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Ledger]!
  ledgersConnection(where: LedgerWhereInput, orderBy: LedgerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LedgerConnection!
  odd(where: OddWhereUniqueInput!): Odd
  odds(where: OddWhereInput, orderBy: OddOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Odd]!
  oddsConnection(where: OddWhereInput, orderBy: OddOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): OddConnection!
  oddsType(where: OddsTypeWhereUniqueInput!): OddsType
  oddsTypes(where: OddsTypeWhereInput, orderBy: OddsTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [OddsType]!
  oddsTypesConnection(where: OddsTypeWhereInput, orderBy: OddsTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): OddsTypeConnection!
  outcome(where: OutcomeWhereUniqueInput!): Outcome
  outcomes(where: OutcomeWhereInput, orderBy: OutcomeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Outcome]!
  outcomesConnection(where: OutcomeWhereInput, orderBy: OutcomeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): OutcomeConnection!
  overUnder(where: OverUnderWhereUniqueInput!): OverUnder
  overUnders(where: OverUnderWhereInput, orderBy: OverUnderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [OverUnder]!
  overUndersConnection(where: OverUnderWhereInput, orderBy: OverUnderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): OverUnderConnection!
  sport(where: SportWhereUniqueInput!): Sport
  sports(where: SportWhereInput, orderBy: SportOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Sport]!
  sportsConnection(where: SportWhereInput, orderBy: SportOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SportConnection!
  team(where: TeamWhereUniqueInput!): Team
  teams(where: TeamWhereInput, orderBy: TeamOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Team]!
  teamsConnection(where: TeamWhereInput, orderBy: TeamOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TeamConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  wager(where: WagerWhereUniqueInput!): Wager
  wagers(where: WagerWhereInput, orderBy: WagerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Wager]!
  wagersConnection(where: WagerWhereInput, orderBy: WagerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): WagerConnection!
  wagerType(where: WagerTypeWhereUniqueInput!): WagerType
  wagerTypes(where: WagerTypeWhereInput, orderBy: WagerTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [WagerType]!
  wagerTypesConnection(where: WagerTypeWhereInput, orderBy: WagerTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): WagerTypeConnection!
  node(id: ID!): Node
}

type Sport {
  id: ID!
  sportName: String!
  game(where: GameWhereInput, orderBy: GameOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Game!]
}

type SportConnection {
  pageInfo: PageInfo!
  edges: [SportEdge]!
  aggregate: AggregateSport!
}

input SportCreateInput {
  id: ID
  sportName: String!
  game: GameCreateManyWithoutSportInput
}

input SportCreateOneWithoutGameInput {
  create: SportCreateWithoutGameInput
  connect: SportWhereUniqueInput
}

input SportCreateWithoutGameInput {
  id: ID
  sportName: String!
}

type SportEdge {
  node: Sport!
  cursor: String!
}

enum SportOrderByInput {
  id_ASC
  id_DESC
  sportName_ASC
  sportName_DESC
}

type SportPreviousValues {
  id: ID!
  sportName: String!
}

type SportSubscriptionPayload {
  mutation: MutationType!
  node: Sport
  updatedFields: [String!]
  previousValues: SportPreviousValues
}

input SportSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SportWhereInput
  AND: [SportSubscriptionWhereInput!]
  OR: [SportSubscriptionWhereInput!]
  NOT: [SportSubscriptionWhereInput!]
}

input SportUpdateInput {
  sportName: String
  game: GameUpdateManyWithoutSportInput
}

input SportUpdateManyMutationInput {
  sportName: String
}

input SportUpdateOneRequiredWithoutGameInput {
  create: SportCreateWithoutGameInput
  update: SportUpdateWithoutGameDataInput
  upsert: SportUpsertWithoutGameInput
  connect: SportWhereUniqueInput
}

input SportUpdateWithoutGameDataInput {
  sportName: String
}

input SportUpsertWithoutGameInput {
  update: SportUpdateWithoutGameDataInput!
  create: SportCreateWithoutGameInput!
}

input SportWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  sportName: String
  sportName_not: String
  sportName_in: [String!]
  sportName_not_in: [String!]
  sportName_lt: String
  sportName_lte: String
  sportName_gt: String
  sportName_gte: String
  sportName_contains: String
  sportName_not_contains: String
  sportName_starts_with: String
  sportName_not_starts_with: String
  sportName_ends_with: String
  sportName_not_ends_with: String
  game_every: GameWhereInput
  game_some: GameWhereInput
  game_none: GameWhereInput
  AND: [SportWhereInput!]
  OR: [SportWhereInput!]
  NOT: [SportWhereInput!]
}

input SportWhereUniqueInput {
  id: ID
}

type Subscription {
  game(where: GameSubscriptionWhereInput): GameSubscriptionPayload
  ledger(where: LedgerSubscriptionWhereInput): LedgerSubscriptionPayload
  odd(where: OddSubscriptionWhereInput): OddSubscriptionPayload
  oddsType(where: OddsTypeSubscriptionWhereInput): OddsTypeSubscriptionPayload
  outcome(where: OutcomeSubscriptionWhereInput): OutcomeSubscriptionPayload
  overUnder(where: OverUnderSubscriptionWhereInput): OverUnderSubscriptionPayload
  sport(where: SportSubscriptionWhereInput): SportSubscriptionPayload
  team(where: TeamSubscriptionWhereInput): TeamSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
  wager(where: WagerSubscriptionWhereInput): WagerSubscriptionPayload
  wagerType(where: WagerTypeSubscriptionWhereInput): WagerTypeSubscriptionPayload
}

type Team {
  id: ID!
  teamName: String!
  city: String!
  homeGames(where: GameWhereInput, orderBy: GameOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Game!]
  awayGames(where: GameWhereInput, orderBy: GameOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Game!]
}

type TeamConnection {
  pageInfo: PageInfo!
  edges: [TeamEdge]!
  aggregate: AggregateTeam!
}

input TeamCreateInput {
  id: ID
  teamName: String!
  city: String!
  homeGames: GameCreateManyWithoutHomeTeamInput
  awayGames: GameCreateManyWithoutAwayTeamInput
}

input TeamCreateOneInput {
  create: TeamCreateInput
  connect: TeamWhereUniqueInput
}

input TeamCreateOneWithoutAwayGamesInput {
  create: TeamCreateWithoutAwayGamesInput
  connect: TeamWhereUniqueInput
}

input TeamCreateOneWithoutHomeGamesInput {
  create: TeamCreateWithoutHomeGamesInput
  connect: TeamWhereUniqueInput
}

input TeamCreateWithoutAwayGamesInput {
  id: ID
  teamName: String!
  city: String!
  homeGames: GameCreateManyWithoutHomeTeamInput
}

input TeamCreateWithoutHomeGamesInput {
  id: ID
  teamName: String!
  city: String!
  awayGames: GameCreateManyWithoutAwayTeamInput
}

type TeamEdge {
  node: Team!
  cursor: String!
}

enum TeamOrderByInput {
  id_ASC
  id_DESC
  teamName_ASC
  teamName_DESC
  city_ASC
  city_DESC
}

type TeamPreviousValues {
  id: ID!
  teamName: String!
  city: String!
}

type TeamSubscriptionPayload {
  mutation: MutationType!
  node: Team
  updatedFields: [String!]
  previousValues: TeamPreviousValues
}

input TeamSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TeamWhereInput
  AND: [TeamSubscriptionWhereInput!]
  OR: [TeamSubscriptionWhereInput!]
  NOT: [TeamSubscriptionWhereInput!]
}

input TeamUpdateDataInput {
  teamName: String
  city: String
  homeGames: GameUpdateManyWithoutHomeTeamInput
  awayGames: GameUpdateManyWithoutAwayTeamInput
}

input TeamUpdateInput {
  teamName: String
  city: String
  homeGames: GameUpdateManyWithoutHomeTeamInput
  awayGames: GameUpdateManyWithoutAwayTeamInput
}

input TeamUpdateManyMutationInput {
  teamName: String
  city: String
}

input TeamUpdateOneInput {
  create: TeamCreateInput
  update: TeamUpdateDataInput
  upsert: TeamUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: TeamWhereUniqueInput
}

input TeamUpdateOneRequiredWithoutAwayGamesInput {
  create: TeamCreateWithoutAwayGamesInput
  update: TeamUpdateWithoutAwayGamesDataInput
  upsert: TeamUpsertWithoutAwayGamesInput
  connect: TeamWhereUniqueInput
}

input TeamUpdateOneRequiredWithoutHomeGamesInput {
  create: TeamCreateWithoutHomeGamesInput
  update: TeamUpdateWithoutHomeGamesDataInput
  upsert: TeamUpsertWithoutHomeGamesInput
  connect: TeamWhereUniqueInput
}

input TeamUpdateWithoutAwayGamesDataInput {
  teamName: String
  city: String
  homeGames: GameUpdateManyWithoutHomeTeamInput
}

input TeamUpdateWithoutHomeGamesDataInput {
  teamName: String
  city: String
  awayGames: GameUpdateManyWithoutAwayTeamInput
}

input TeamUpsertNestedInput {
  update: TeamUpdateDataInput!
  create: TeamCreateInput!
}

input TeamUpsertWithoutAwayGamesInput {
  update: TeamUpdateWithoutAwayGamesDataInput!
  create: TeamCreateWithoutAwayGamesInput!
}

input TeamUpsertWithoutHomeGamesInput {
  update: TeamUpdateWithoutHomeGamesDataInput!
  create: TeamCreateWithoutHomeGamesInput!
}

input TeamWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  teamName: String
  teamName_not: String
  teamName_in: [String!]
  teamName_not_in: [String!]
  teamName_lt: String
  teamName_lte: String
  teamName_gt: String
  teamName_gte: String
  teamName_contains: String
  teamName_not_contains: String
  teamName_starts_with: String
  teamName_not_starts_with: String
  teamName_ends_with: String
  teamName_not_ends_with: String
  city: String
  city_not: String
  city_in: [String!]
  city_not_in: [String!]
  city_lt: String
  city_lte: String
  city_gt: String
  city_gte: String
  city_contains: String
  city_not_contains: String
  city_starts_with: String
  city_not_starts_with: String
  city_ends_with: String
  city_not_ends_with: String
  homeGames_every: GameWhereInput
  homeGames_some: GameWhereInput
  homeGames_none: GameWhereInput
  awayGames_every: GameWhereInput
  awayGames_some: GameWhereInput
  awayGames_none: GameWhereInput
  AND: [TeamWhereInput!]
  OR: [TeamWhereInput!]
  NOT: [TeamWhereInput!]
}

input TeamWhereUniqueInput {
  id: ID
}

type User {
  id: ID!
  firstName: String!
  lastName: String!
  userName: String!
  password: String!
  email: String!
  phoneNumber: String
  balance: Float!
  userVerified: Boolean!
  ledgerEntries(where: LedgerWhereInput, orderBy: LedgerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Ledger!]
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  firstName: String!
  lastName: String!
  userName: String!
  password: String!
  email: String!
  phoneNumber: String
  balance: Float!
  userVerified: Boolean!
  ledgerEntries: LedgerCreateManyWithoutUserInput
}

input UserCreateOneWithoutLedgerEntriesInput {
  create: UserCreateWithoutLedgerEntriesInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutLedgerEntriesInput {
  id: ID
  firstName: String!
  lastName: String!
  userName: String!
  password: String!
  email: String!
  phoneNumber: String
  balance: Float!
  userVerified: Boolean!
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  firstName_ASC
  firstName_DESC
  lastName_ASC
  lastName_DESC
  userName_ASC
  userName_DESC
  password_ASC
  password_DESC
  email_ASC
  email_DESC
  phoneNumber_ASC
  phoneNumber_DESC
  balance_ASC
  balance_DESC
  userVerified_ASC
  userVerified_DESC
}

type UserPreviousValues {
  id: ID!
  firstName: String!
  lastName: String!
  userName: String!
  password: String!
  email: String!
  phoneNumber: String
  balance: Float!
  userVerified: Boolean!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  firstName: String
  lastName: String
  userName: String
  password: String
  email: String
  phoneNumber: String
  balance: Float
  userVerified: Boolean
  ledgerEntries: LedgerUpdateManyWithoutUserInput
}

input UserUpdateManyMutationInput {
  firstName: String
  lastName: String
  userName: String
  password: String
  email: String
  phoneNumber: String
  balance: Float
  userVerified: Boolean
}

input UserUpdateOneRequiredWithoutLedgerEntriesInput {
  create: UserCreateWithoutLedgerEntriesInput
  update: UserUpdateWithoutLedgerEntriesDataInput
  upsert: UserUpsertWithoutLedgerEntriesInput
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutLedgerEntriesDataInput {
  firstName: String
  lastName: String
  userName: String
  password: String
  email: String
  phoneNumber: String
  balance: Float
  userVerified: Boolean
}

input UserUpsertWithoutLedgerEntriesInput {
  update: UserUpdateWithoutLedgerEntriesDataInput!
  create: UserCreateWithoutLedgerEntriesInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  firstName: String
  firstName_not: String
  firstName_in: [String!]
  firstName_not_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_gt: String
  firstName_gte: String
  firstName_contains: String
  firstName_not_contains: String
  firstName_starts_with: String
  firstName_not_starts_with: String
  firstName_ends_with: String
  firstName_not_ends_with: String
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  userName: String
  userName_not: String
  userName_in: [String!]
  userName_not_in: [String!]
  userName_lt: String
  userName_lte: String
  userName_gt: String
  userName_gte: String
  userName_contains: String
  userName_not_contains: String
  userName_starts_with: String
  userName_not_starts_with: String
  userName_ends_with: String
  userName_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  phoneNumber: String
  phoneNumber_not: String
  phoneNumber_in: [String!]
  phoneNumber_not_in: [String!]
  phoneNumber_lt: String
  phoneNumber_lte: String
  phoneNumber_gt: String
  phoneNumber_gte: String
  phoneNumber_contains: String
  phoneNumber_not_contains: String
  phoneNumber_starts_with: String
  phoneNumber_not_starts_with: String
  phoneNumber_ends_with: String
  phoneNumber_not_ends_with: String
  balance: Float
  balance_not: Float
  balance_in: [Float!]
  balance_not_in: [Float!]
  balance_lt: Float
  balance_lte: Float
  balance_gt: Float
  balance_gte: Float
  userVerified: Boolean
  userVerified_not: Boolean
  ledgerEntries_every: LedgerWhereInput
  ledgerEntries_some: LedgerWhereInput
  ledgerEntries_none: LedgerWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
}

type Wager {
  id: ID!
  ledger: Ledger!
  odds: Odd!
  oddsType: OddsType!
  pickedOverUnder: OverUnder
  pickedTeam: Team
}

type WagerConnection {
  pageInfo: PageInfo!
  edges: [WagerEdge]!
  aggregate: AggregateWager!
}

input WagerCreateInput {
  id: ID
  ledger: LedgerCreateOneInput!
  odds: OddCreateOneInput!
  oddsType: OddsTypeCreateOneInput!
  pickedOverUnder: OverUnderCreateOneInput
  pickedTeam: TeamCreateOneInput
}

type WagerEdge {
  node: Wager!
  cursor: String!
}

enum WagerOrderByInput {
  id_ASC
  id_DESC
}

type WagerPreviousValues {
  id: ID!
}

type WagerSubscriptionPayload {
  mutation: MutationType!
  node: Wager
  updatedFields: [String!]
  previousValues: WagerPreviousValues
}

input WagerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: WagerWhereInput
  AND: [WagerSubscriptionWhereInput!]
  OR: [WagerSubscriptionWhereInput!]
  NOT: [WagerSubscriptionWhereInput!]
}

type WagerType {
  id: ID!
  wagerType: String!
  ledgers(where: LedgerWhereInput, orderBy: LedgerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Ledger!]
}

type WagerTypeConnection {
  pageInfo: PageInfo!
  edges: [WagerTypeEdge]!
  aggregate: AggregateWagerType!
}

input WagerTypeCreateInput {
  id: ID
  wagerType: String!
  ledgers: LedgerCreateManyWithoutWagerTypeInput
}

input WagerTypeCreateOneWithoutLedgersInput {
  create: WagerTypeCreateWithoutLedgersInput
  connect: WagerTypeWhereUniqueInput
}

input WagerTypeCreateWithoutLedgersInput {
  id: ID
  wagerType: String!
}

type WagerTypeEdge {
  node: WagerType!
  cursor: String!
}

enum WagerTypeOrderByInput {
  id_ASC
  id_DESC
  wagerType_ASC
  wagerType_DESC
}

type WagerTypePreviousValues {
  id: ID!
  wagerType: String!
}

type WagerTypeSubscriptionPayload {
  mutation: MutationType!
  node: WagerType
  updatedFields: [String!]
  previousValues: WagerTypePreviousValues
}

input WagerTypeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: WagerTypeWhereInput
  AND: [WagerTypeSubscriptionWhereInput!]
  OR: [WagerTypeSubscriptionWhereInput!]
  NOT: [WagerTypeSubscriptionWhereInput!]
}

input WagerTypeUpdateInput {
  wagerType: String
  ledgers: LedgerUpdateManyWithoutWagerTypeInput
}

input WagerTypeUpdateManyMutationInput {
  wagerType: String
}

input WagerTypeUpdateOneRequiredWithoutLedgersInput {
  create: WagerTypeCreateWithoutLedgersInput
  update: WagerTypeUpdateWithoutLedgersDataInput
  upsert: WagerTypeUpsertWithoutLedgersInput
  connect: WagerTypeWhereUniqueInput
}

input WagerTypeUpdateWithoutLedgersDataInput {
  wagerType: String
}

input WagerTypeUpsertWithoutLedgersInput {
  update: WagerTypeUpdateWithoutLedgersDataInput!
  create: WagerTypeCreateWithoutLedgersInput!
}

input WagerTypeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  wagerType: String
  wagerType_not: String
  wagerType_in: [String!]
  wagerType_not_in: [String!]
  wagerType_lt: String
  wagerType_lte: String
  wagerType_gt: String
  wagerType_gte: String
  wagerType_contains: String
  wagerType_not_contains: String
  wagerType_starts_with: String
  wagerType_not_starts_with: String
  wagerType_ends_with: String
  wagerType_not_ends_with: String
  ledgers_every: LedgerWhereInput
  ledgers_some: LedgerWhereInput
  ledgers_none: LedgerWhereInput
  AND: [WagerTypeWhereInput!]
  OR: [WagerTypeWhereInput!]
  NOT: [WagerTypeWhereInput!]
}

input WagerTypeWhereUniqueInput {
  id: ID
}

input WagerUpdateInput {
  ledger: LedgerUpdateOneRequiredInput
  odds: OddUpdateOneRequiredInput
  oddsType: OddsTypeUpdateOneRequiredInput
  pickedOverUnder: OverUnderUpdateOneInput
  pickedTeam: TeamUpdateOneInput
}

input WagerWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  ledger: LedgerWhereInput
  odds: OddWhereInput
  oddsType: OddsTypeWhereInput
  pickedOverUnder: OverUnderWhereInput
  pickedTeam: TeamWhereInput
  AND: [WagerWhereInput!]
  OR: [WagerWhereInput!]
  NOT: [WagerWhereInput!]
}

input WagerWhereUniqueInput {
  id: ID
}
`
      }
    